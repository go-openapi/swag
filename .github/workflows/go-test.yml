name: go test

permissions:
  contents: read
  pull-requests: read

on:
  push:
    tags:
      - v*
    branches:
      - master

  pull_request:

jobs:
  lint:
    name: Go lint mono-repo
    runs-on: ubuntu-latest
    steps:
      -
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: '0'
      -
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true
          cache-dependency-path: '**/go.sum'
      -
        name: Install golangci-lint
        uses: golangci/golangci-lint-action@1e7e51e771db61008b38414a730f564565cf7c20 # v9.2.0
        with:
          version: latest
          skip-cache: true
          install-only: true
      -
        name: Lint multiple modules
        # golangci-lint doesn't support go.work to lint multiple modules in one single pass
        run: |
          set -euxo pipefail

          git fetch origin master
          git show --no-patch --oneline origin/master

          while read module_location ; do
            pushd "${module_location}"
            golangci-lint run --new-from-rev origin/master
            popd
          done < <(go list -f '{{.Dir}}' -m)

  module-test:
    name: Unit tests
    runs-on: ${{ matrix.os }}
    needs: [ lint ]

    strategy:
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
        go_version: ['oldstable', 'stable' ]
    env:
      TEST_REPORT: 'all_modules.report.${{ matrix.os }}.${{ matrix.go_version }}.json'

    steps:
    - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
    - uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
      with:
        go-version: '${{ matrix.go_version }}'
        check-latest: true
        cache: true
        cache-dependency-path: '**/go.sum'

    - name: Run unit tests on all modules in this repo
      shell: bash
      env:
        # *.coverage.* pattern is automatically detected by codecov
        COVER_PROFILE: 'all_modules.coverage.${{ matrix.os }}.${{ matrix.go_version }}.out'
      run: |
        # when go1.25 becomes the oldstable, we may replace this bash with "go test work"
        declare -a ALL_MODULES
        BASH_MAJOR=$(echo $BASH_VERSION|cut -d'.' -f1)
        if [[ "${BASH_MAJOR}" -ge 4 ]] ; then
          mapfile ALL_MODULES < <(go list -f '{{.Dir}}/...' -m)
        else
          # for older bash versions, e.g. on macOS runner. This fallback will eventually disappear.
          while read line ; do
            ALL_MODULES+=("${line}")
          done < <(go list -f '{{.Dir}}/...' -m)
        fi
        echo "::notice title=Modules found::${ALL_MODULES[@]}"

        # with go.work file enabled, go test recognizes sub-modules and collects all packages to be covered
        # without specifying -coverpkg.
        go test -race -coverprofile="${COVER_PROFILE}" -covermode=atomic -json ${ALL_MODULES[@]}|tee -a "${TEST_REPORT}"

    - name: Upload coverage to codecov
      if: ${{ success() }}  # we do this only if all previous steps succeeded
      uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # v5.5.2
      with:
        name: Multi modules aggregated coverage
        flags: '${{ matrix.go_version }}-${{ matrix.os }}'
        fail_ci_if_error: false
        verbose: false

    - name: Upload JSON test Results
      if: always()
      uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
      with:
        name: 'all_modules.report.${{ matrix.os }}.${{ matrix.go_version }}'
        path: ${{ env.TEST_REPORT }}

  test:
    needs: [ module-test ]
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Tests complete
        run: |
          echo "::notice title=Success::All tests completed"

  collect-reports:
    if: always()
    needs: [ module-test ]
    name: Collect and merge test reports
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true

      - name: Download all JSON artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          run-id: "${{ github.run_id }}"
          pattern: "all_modules.report.*"
          # artifacts resolve as folders
          path: reports/

      - name: Convert test reports to a merged JUnit XML
        # NOTE: codecov test reports only support JUnit format at this moment. See https://docs.codecov.com/docs/test-analytics.
        # Ideally, codecov improve a bit their platform, so we may only need a single pass to CTRF format.
        #
        # As a contemplated alternative, we could use gotestsum above to produce the JUnit XML directly.
        run: |
          go install github.com/jstemmer/go-junit-report/v2@latest
          cat reports/*/*.json | go-junit-report -parser gojson -out=reports/junit_report.xml

      - name: Upload test results to Codecov
        if: always()
        uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # v5.5.2
        with:
          files: '**/junit_report.xml'
          report_type: 'test_results'
          fail_ci_if_error: false
          handle_no_reports_found: true
          verbose: true

      - name: Convert test reports to CTRF JSON
        run: |
          go install github.com/ctrf-io/go-ctrf-json-reporter/cmd/go-ctrf-json-reporter@v0.0.10

          appName="swag"
          buildNumber="${{ github.run_id }}"
          appVersion="${{ github.event.pull_request.head.sha }}"

          while read report ; do
            echo "::notice::converting report: ${report}"
            #TEST_REPORT: 'all_modules.report.${{ matrix.os }}.${{ matrix.go_version }}.json'
            reformated=$(echo "${report##*/}"|sed -E 's/(go)([[:digit:]]+)\.([[:digit:]]+)/\1\2\3/') # e.g. go1.24 becomes go124
            mapfile -d'.' -t -s 2 -n 2 split < <(echo $reformated) # skip the first 2 parts, stop on 2 more parts
            osPlatform="${split[0]}"
            osRelease="${split[1]}"

            go-ctrf-json-reporter \
              -verbose \
              -appName "${appName}" \
              -appVersion "${appVersion}" \
              -buildNumber "${buildNumber}" \
              -osPlatform "${osPlatform}" \
              -osRelease "${osRelease}" \
              -output "./reports/ctrf_report_${osPlatform}_${osRelease}.json" \
              -quiet < "${report}"
          done < <(find reports -name \*.json)

      # NOTE: at this moment, we don't upload CTRF reports as artifacts.
      # Some of the CTRF reports are therefore not available (flaky tests, history, ...).
      #
      # See https://github.com/ctrf-io/github-test-reporter?tab=readme-ov-file#report-showcase
      # for more reporting possibilities. At the moment, we keep it simple, as most advanced features
      # require a github token (thus adding the complexity of a separate workflow starting on pull_request_target).
      #
      # For the moment, we are contented with these simple reports. This is an opportunity to compare the insight they
      # provide as compared to what is uploaded to codecov.
      #
      # Codecov analytics are pretty poor at this moment. On the other hand, they manage the bot that pushes back
      # PR comments.
      #
      # They also handle the storage of past test reports, so as to assess flaky tests.
      - name: Publish Test Summary Results
        uses: ctrf-io/github-test-reporter@024bc4b64d997ca9da86833c6b9548c55c620e40 # v1.0.26
        with:
          report-path: 'reports/ctrf_report_*.json'
          use-suite-name: true
          summary-report: true             # post a report to the github actions summary
          github-report: true
          failed-folded-report: true

