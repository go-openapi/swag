// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package testintegration

import (
	"sync"

	"github.com/mailru/easyjson/jlexer"
	"github.com/mailru/easyjson/jwriter"
)

// Ensure that MockEJMarshaler does implement EJMarshaler.
// If this is not the case, regenerate this file with mockery.
var _ EJMarshaler = &MockEJMarshaler{}

// MockEJMarshaler is a mock implementation of EJMarshaler.
//
//	func TestSomethingThatUsesEJMarshaler(t *testing.T) {
//
//		// make and configure a mocked EJMarshaler
//		mockedEJMarshaler := &MockEJMarshaler{
//			MarshalEasyJSONFunc: func(w *jwriter.Writer)  {
//				panic("mock out the MarshalEasyJSON method")
//			},
//		}
//
//		// use mockedEJMarshaler in code that requires EJMarshaler
//		// and then make assertions.
//
//	}
type MockEJMarshaler struct {
	// MarshalEasyJSONFunc mocks the MarshalEasyJSON method.
	MarshalEasyJSONFunc func(w *jwriter.Writer)

	// calls tracks calls to the methods.
	calls struct {
		// MarshalEasyJSON holds details about calls to the MarshalEasyJSON method.
		MarshalEasyJSON []struct {
			// W is the w argument value.
			W *jwriter.Writer
		}
	}
	lockMarshalEasyJSON sync.RWMutex
}

// MarshalEasyJSON calls MarshalEasyJSONFunc.
func (mock *MockEJMarshaler) MarshalEasyJSON(w *jwriter.Writer) {
	if mock.MarshalEasyJSONFunc == nil {
		panic("MockEJMarshaler.MarshalEasyJSONFunc: method is nil but EJMarshaler.MarshalEasyJSON was just called")
	}
	callInfo := struct {
		W *jwriter.Writer
	}{
		W: w,
	}
	mock.lockMarshalEasyJSON.Lock()
	mock.calls.MarshalEasyJSON = append(mock.calls.MarshalEasyJSON, callInfo)
	mock.lockMarshalEasyJSON.Unlock()
	mock.MarshalEasyJSONFunc(w)
}

// MarshalEasyJSONCalls gets all the calls that were made to MarshalEasyJSON.
// Check the length with:
//
//	len(mockedEJMarshaler.MarshalEasyJSONCalls())
func (mock *MockEJMarshaler) MarshalEasyJSONCalls() []struct {
	W *jwriter.Writer
} {
	var calls []struct {
		W *jwriter.Writer
	}
	mock.lockMarshalEasyJSON.RLock()
	calls = mock.calls.MarshalEasyJSON
	mock.lockMarshalEasyJSON.RUnlock()
	return calls
}

// Ensure that MockEJUnmarshaler does implement EJUnmarshaler.
// If this is not the case, regenerate this file with mockery.
var _ EJUnmarshaler = &MockEJUnmarshaler{}

// MockEJUnmarshaler is a mock implementation of EJUnmarshaler.
//
//	func TestSomethingThatUsesEJUnmarshaler(t *testing.T) {
//
//		// make and configure a mocked EJUnmarshaler
//		mockedEJUnmarshaler := &MockEJUnmarshaler{
//			UnmarshalEasyJSONFunc: func(w *jlexer.Lexer)  {
//				panic("mock out the UnmarshalEasyJSON method")
//			},
//		}
//
//		// use mockedEJUnmarshaler in code that requires EJUnmarshaler
//		// and then make assertions.
//
//	}
type MockEJUnmarshaler struct {
	// UnmarshalEasyJSONFunc mocks the UnmarshalEasyJSON method.
	UnmarshalEasyJSONFunc func(w *jlexer.Lexer)

	// calls tracks calls to the methods.
	calls struct {
		// UnmarshalEasyJSON holds details about calls to the UnmarshalEasyJSON method.
		UnmarshalEasyJSON []struct {
			// W is the w argument value.
			W *jlexer.Lexer
		}
	}
	lockUnmarshalEasyJSON sync.RWMutex
}

// UnmarshalEasyJSON calls UnmarshalEasyJSONFunc.
func (mock *MockEJUnmarshaler) UnmarshalEasyJSON(w *jlexer.Lexer) {
	if mock.UnmarshalEasyJSONFunc == nil {
		panic("MockEJUnmarshaler.UnmarshalEasyJSONFunc: method is nil but EJUnmarshaler.UnmarshalEasyJSON was just called")
	}
	callInfo := struct {
		W *jlexer.Lexer
	}{
		W: w,
	}
	mock.lockUnmarshalEasyJSON.Lock()
	mock.calls.UnmarshalEasyJSON = append(mock.calls.UnmarshalEasyJSON, callInfo)
	mock.lockUnmarshalEasyJSON.Unlock()
	mock.UnmarshalEasyJSONFunc(w)
}

// UnmarshalEasyJSONCalls gets all the calls that were made to UnmarshalEasyJSON.
// Check the length with:
//
//	len(mockedEJUnmarshaler.UnmarshalEasyJSONCalls())
func (mock *MockEJUnmarshaler) UnmarshalEasyJSONCalls() []struct {
	W *jlexer.Lexer
} {
	var calls []struct {
		W *jlexer.Lexer
	}
	mock.lockUnmarshalEasyJSON.RLock()
	calls = mock.calls.UnmarshalEasyJSON
	mock.lockUnmarshalEasyJSON.RUnlock()
	return calls
}
